--- Work Log ---

00:00 Start work

Reading paper and background to understand what the paper is trying to do.

00:37 First pass through theory section of article complete, Very basic understanding

55:00 First pass through implementation section, Very basic understanding

5:16:00 Attempt a couple fixes which I thought might fix the simulation. These fixes failed.

9:31:00 With August: Managed to figure out that example 3 seems to be producing example 2 from the paper, but perhaps with a different smoother. CPU times are an order of magnitude longer.

--- Notes ---

AIM: Appoximate Inversion Method

Numerically solving these types of problems is challenging due to the large matrix size and enormous numbers of operations. People are trying to speed this up with things such as AIM.

Previous work on AIM was in one dimension where solutions were fairly simple. This paper extends this to two dimensions by using a block multigrid method to solve the now complex block matrices. (AIMGM)

It appears we have code for example 2 only. I don't know what example 3 was meant to be, but there is no example 3 in the paper and the initial conditions seem mirror those in 'example 2'.

The problem is that the answers I'm getting with the given example 2 aren't quite right. I will now go through the program and verify that everything looks like what was described in the paper.

While not discussed in the paper at first, M denotes the internal spacial resolution. The spatial grid goes from 0 <= i <= M+1 for both the x coordinate and the y coordinate. This makes for M^2 internal spatial points. Because they are solving a 'boundary value problem', the edge coordinates are not part of the calculation of the next time step.

I'm currenty cleaning up the code and adding comments so it's more clear what is going on. To help with this, I've applied my favorite coding style with astyle.

If the grid matrix is u_x,y The code's vector packing convention is: u_1,1 u_2,1 u_3,1 ... u_N,1 u_1,2 u_2,2 .... So First iterate by x, then the next set is an iteration in y.

I was incorrect earlier, example2.cpp seems to be for a problem that isn't in the article. example3.cpp seems to be closer.

It has thus far been difficult to decifer some of this code. It is written in a very obscure way.

Frac_div_appro_coeff[k] = g^{(a)}_k <- Deciphered by comparing article and code.


