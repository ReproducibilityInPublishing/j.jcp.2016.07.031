--- Work Log ---

00:00 Start work

Reading paper and background to understand what the paper is trying to do.

00:37 First pass through theory section of article complete, Very basic understanding

55:00 First pass through implementation section, Very basic understanding

5:16:00 Attempt a couple fixes which I thought might fix the simulation. These fixes failed.

9:31:00 With August: Managed to figure out that example 3 seems to be producing example 2 from the paper, but perhaps with a different smoother. CPU times are an order of magnitude longer.

10:11:45 Recap: rhs (from code) is the b (from paper) vector. Originally, I thought it was simply equal to f(x,y,t) from the paper, however there seems to be some subtlety related to how this b vector is defined. from the paper they say "b is a given vector containing information about f, phi, and psi on grid points"

+1.5 hrs (didn't capture the time)

11:01:43: Found a mistake in the paper!!! for example 2 f(x,y,t) = \frac{\Gamma(4)xyt^{3-\alpha}}{\Gamma(4-\alpha)}-(x^2+y^2)exp(xy)t^3 This means the example3 code we got is actually correct! I've also figured out how the edge terms for b are calculated. You simply refer to the discretization of the laplacian in the equation (4.3) and evaluate it on the edges of the domain. This quickly gives the edge terms from the code.

+45 minutes (didn't capture the time)

11:40:26: Implemented example 1 as in the paper. I now get close to the values in the table along with cpu times an order of magnitude higher than the paper just like example 2

+1.5 hrs (didn't capture the time)

+30 mins (didn't capture the time)

--- Notes ---

AIM: Appoximate Inversion Method

Numerically solving these types of problems is challenging due to the large matrix size and enormous numbers of operations. People are trying to speed this up with things such as AIM.

Previous work on AIM was in one dimension where solutions were fairly simple. This paper extends this to two dimensions by using a block multigrid method to solve the now complex block matrices. (AIMGM)

It appears we have code for example 2 only. I don't know what example 3 was meant to be, but there is no example 3 in the paper and the initial conditions seem mirror those in 'example 2'.

The problem is that the answers I'm getting with the given example 2 aren't quite right. I will now go through the program and verify that everything looks like what was described in the paper.

While not discussed in the paper at first, M denotes the internal spacial resolution. The spatial grid goes from 0 <= i <= M+1 for both the x coordinate and the y coordinate. This makes for M^2 internal spatial points. Because they are solving a 'boundary value problem', the edge coordinates are not part of the calculation of the next time step.

I'm currenty cleaning up the code and adding comments so it's more clear what is going on. To help with this, I've applied my favorite coding style with astyle.

If the grid matrix is u_x,y The code's vector packing convention is: u_1,1 u_2,1 u_3,1 ... u_N,1 u_1,2 u_2,2 .... So First iterate by x, then the next set is an iteration in y.

I was incorrect earlier, example2.cpp seems to be for a problem that isn't in the article. example3.cpp seems to be closer.

It has thus far been difficult to decifer some of this code. It is written in a very obscure way.

Frac_div_appro_coeff[k] = g^{(a)}_k <- Deciphered by comparing article and code.

Remaining to be understood: How the rhs vector (b in the article) is created from the f function, and boundary conditions defined for the problem.

article uses incorrect f(x,y,t)! should be as in the code. boundary conditions are calculated from the laplacian term. Just evaluate near the boundaries to see where the terms come from.

example2.cpp that they sent us is the same as Example 2 from the paper except, u(x,y,t) = exp(x+y)t^3, p(x,y) = exp(xy), f(x,y,t) = exp(x+y)((Gamma(4)/Gamma(4-alpha))*t^(3-alpha)-(2+x+y)*exp(xy)t^3) I've added it in as example3.cpp now.
